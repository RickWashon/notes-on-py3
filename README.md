# notes-on-py3

python 使用的是对象引用，所以在使用赋值操作符(=)时，进行的不是复制操作，如果右边的操作数是一个对象引用，则左边的操作数将设置为一个对象引用，
并与右边操作数指向同一内存对象。如此操作，可以减少时间和空间。
>>> a = ['john','sara','diego']
>>> b = a
>>> b
['john','sara','diego']
>>> b[0] = 'trump'
>>> a,b
(['trump','sara','diego'],['trump','sara','diego'])
上面对列表变量 b 进行改变，由于 b 和 a 指向同一列表，对任一对象引用进行的改变对另一个对象引用都是可见的。
如果我们需要一个单独的副本，可以采用提取数据片的方法，数据片总是取自某一数据的单独副本，如果需要整个数据的副本，可以通过下面方法实现：
>>> a = ['john','sara','diego']
>>> b = a[:]
>>> b[0] = 'trump'
>>> a,b
(['john','sara','diego'],['trump','sara','diego'])
对于列表、字典、集合，等效操作可以用 list.copy(), dict.copy(), set.copy()实现。此外，copy 提供了 copy.copy() 函数。对于内置组合数据类型，
另一种复制方法是使用类型名作为函数，将待复制的数据作为参数，如：
>>> copy_of_dict_d = dict(d)
>>> copy_of_list_l = list(l)
>>> copy_of_set_s = set(s)
>>> copy_of_tuple_t = tuple(t)
值得注意的是，这些复制技术都是浅拷贝，对于可变的数据类型如嵌套的组合类型，相关对象同时被原组合和复制后的组合引用。
>>> a = [1,2,3,[3,2,1]]
>>> b = a[:]
>>> a,b
([1,2,3,[3,2,1]],[1,2,3,[3,2,1]])
>>> b[0] = 0
>>> b[3][0] = 0
>>> a,b
([1,2,3,[0,2,1]],[0,2,3,[0,2,1]])
可见对于嵌套列表的任何改变对 a 和 b 都是可见的。如果需要一个完全独立的副本或潜逃组合，可以进行深拷贝：
>>> import copy
>>> a = [1,2,3,[3,2,1]]
>>> b = copy.deepcopy(a)
>>> b[0] = 0
>>> b[3][0] = 0
>>> a,b
([1,2,3,[3,2,1]],[0,2,3,[0,2,1]])
此时，列表 a 和 b 及其内部所包含的列表项，都是完全独立的。



